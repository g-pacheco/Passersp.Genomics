K = rep(NA, nrow(corres_sub)))
# Match population and add annotation columns
for (j in 1:length(pop)) {
annotation_df[pop == names(pop[j]), c("CHRType", "K")] <- unique(ord[pop == names(pop[j])])
}
# Combine annotation and individual matrix
indiv_matrix <- cbind(annotation_df, corres_sub)
# Remove redundant CHRType and K columns
indiv_matrix <- indiv_matrix[, c("Sample_ID", "CHRType", "K", grep("CHRType\\.|K\\.", colnames(indiv_matrix)))]
return(indiv_matrix)
})
return(result)
}
compute_mean_correlation <- function(corres_ind, pop, exclude_cols) {
N <- length(pop)
mean_cors <- matrix(NA, ncol = length(unique(pop)), nrow = length(unique(pop)))
colnames(mean_cors) <- unique(pop)
rownames(mean_cors) <- unique(pop)
for (i1 in 1:(length(unique(pop)))) {
for (i2 in 1:(length(unique(pop)))) {
p1 <- unique(pop)[i1]
p2 <- unique(pop)[i2]
# Filter out annotation columns if corres_sub has columns
corres_sub <- corres_ind[which(pop == p1), which(pop == p2)]
# Handle NAs in corres_sub
corres_sub[is.na(corres_sub)] <- 0
# Check if corres_sub is not empty
if (!is.null(corres_sub) && nrow(corres_sub) > 0 && ncol(corres_sub) > 0) {
# Check if there's only one individual in one or both populations
if (nrow(corres_sub) <= 1 || ncol(corres_sub) <= 1) {
mean_cors[i1, i2] <- 0
} else {
mean_cors[i1, i2] <- mean(corres_sub, na.rm = TRUE)
}
} else {
mean_cors[i1, i2] <- NA
}
}
}
return(mean_cors)
}
# Applies functions ~
main_list <- compute_on_matrices(corres_ind_list = corres,
pop_list = lapply(annot, function(ann) ann$Population),
ord_list = lapply(corres, orderInds))
View(main_list)
### The BEGINNING ~~~~~
##
# ~ Plots NLSparrow--evalAdmix | First written by Jose Samaniego with later modifications by George Pacheco.
# Cleans the environment ~
rm(list=ls())
# Loads required packages ~
pacman::p_load(tidyverse, reshape2, pheatmap, scales, optparse, plyr, RColorBrewer, extrafont)
source("visFuns.R")
# Sets working directory ~
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Imports data while incorporating annotation ~
corres <- list()
annot <- list()
corres_files <- dir(pattern = ".corres")
annot_files <- dir(pattern = ".labels")
for (k in seq_along(annot_files)) {
annot[[k]] <- read.table(annot_files[k], sep = "\t", header = FALSE, stringsAsFactors = FALSE)
colnames(annot[[k]]) <- c("Sample_ID")
annot[[k]]$Population <- ifelse(grepl("FR0", annot[[k]]$Sample_ID), "Sales",
ifelse(grepl("KAZ", annot[[k]]$Sample_ID), "Chokpak",
ifelse(grepl("Lesina", annot[[k]]$Sample_ID), "Lesina",
ifelse(grepl("Crotone", annot[[k]]$Sample_ID), "Crotone",
ifelse(grepl("Guglionesi", annot[[k]]$Sample_ID), "Guglionesi",
ifelse(grepl("PI22NLD0001M", annot[[k]]$Sample_ID), "Y150239",
ifelse(grepl("PD22NLD0146F", annot[[k]]$Sample_ID), "Garderen",
ifelse(grepl("PD22NLD0147F", annot[[k]]$Sample_ID), "Garderen",
ifelse(grepl("PDOM2022NLD0077M", annot[[k]]$Sample_ID), "Meerkerk",
ifelse(grepl("PDOM2022NLD0", annot[[k]]$Sample_ID), "Utrecht", "Error"))))))))))
corres_df <- as.data.frame(read.table(corres_files[k]))
rownames(corres_df) <- annot[[k]]$Sample_ID
colnames(corres_df) <- annot[[k]]$Sample_ID
corres_df$CHRType <- str_extract(corres_files[k], "(Allosome|Autosomes)")
corres_df$K <- str_extract(corres_files[k], "(K2|K3|K4|K5|K6|K7)")
corres[[k]] <- corres_df}
# Perform individual computation ~
compute_on_matrices <- function(corres_ind_list, pop_list, ord_list) {
result <- lapply(1:length(corres_ind_list), function(i) {
corres_ind <- corres_ind_list[[i]]
pop <- pop_list[[i]]
ord <- ord_list[[i]]
corres_sub <- corres_ind
# Create annotation data frame
annotation_df <- data.frame(Sample_ID = rownames(corres_sub),
CHRType = NA,
K = NA)
# Match population and add annotation columns
for (j in 1:length(pop)) {
match_indices <- pop == names(pop[j])
annotation_df$CHRType[match_indices] <- ord$CHRType[match_indices]
annotation_df$K[match_indices] <- ord$K[match_indices]
}
# Combine annotation and individual matrix
indiv_matrix <- cbind(annotation_df, corres_sub)
# Remove redundant CHRType and K columns
indiv_matrix <- indiv_matrix[, c("Sample_ID", "CHRType", "K", grep("CHRType\\.|K\\.", colnames(indiv_matrix)))]
return(indiv_matrix)
})
return(result)
}
compute_mean_correlation <- function(corres_ind, pop, exclude_cols) {
N <- length(pop)
mean_cors <- matrix(NA, ncol = length(unique(pop)), nrow = length(unique(pop)))
colnames(mean_cors) <- unique(pop)
rownames(mean_cors) <- unique(pop)
for (i1 in 1:(length(unique(pop)))) {
for (i2 in 1:(length(unique(pop)))) {
p1 <- unique(pop)[i1]
p2 <- unique(pop)[i2]
# Filter out annotation columns if corres_sub has columns
corres_sub <- corres_ind[which(pop == p1), which(pop == p2)]
# Handle NAs in corres_sub
corres_sub[is.na(corres_sub)] <- 0
# Check if corres_sub is not empty
if (!is.null(corres_sub) && nrow(corres_sub) > 0 && ncol(corres_sub) > 0) {
# Check if there's only one individual in one or both populations
if (nrow(corres_sub) <= 1 || ncol(corres_sub) <= 1) {
mean_cors[i1, i2] <- 0
} else {
mean_cors[i1, i2] <- mean(corres_sub, na.rm = TRUE)
}
} else {
mean_cors[i1, i2] <- NA
}
}
}
return(mean_cors)
}
# Applies functions ~
main_list <- compute_on_matrices(corres_ind_list = corres,
pop_list = lapply(annot, function(ann) ann$Population),
ord_list = lapply(corres, orderInds))
### The BEGINNING ~~~~~
##
# ~ Plots NLSparrow--evalAdmix | First written by Jose Samaniego with later modifications by George Pacheco.
# Cleans the environment ~
rm(list=ls())
# Loads required packages ~
pacman::p_load(tidyverse, reshape2, pheatmap, scales, optparse, plyr, RColorBrewer, extrafont)
source("visFuns.R")
# Sets working directory ~
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Imports data while incorporating annotation ~
corres <- list()
annot <- list()
corres_files <- dir(pattern = ".corres")
annot_files <- dir(pattern = ".labels")
for (k in seq_along(annot_files)) {
annot[[k]] <- read.table(annot_files[k], sep = "\t", header = FALSE, stringsAsFactors = FALSE)
colnames(annot[[k]]) <- c("Sample_ID")
annot[[k]]$Population <- ifelse(grepl("FR0", annot[[k]]$Sample_ID), "Sales",
ifelse(grepl("KAZ", annot[[k]]$Sample_ID), "Chokpak",
ifelse(grepl("Lesina", annot[[k]]$Sample_ID), "Lesina",
ifelse(grepl("Crotone", annot[[k]]$Sample_ID), "Crotone",
ifelse(grepl("Guglionesi", annot[[k]]$Sample_ID), "Guglionesi",
ifelse(grepl("PI22NLD0001M", annot[[k]]$Sample_ID), "Y150239",
ifelse(grepl("PD22NLD0146F", annot[[k]]$Sample_ID), "Garderen",
ifelse(grepl("PD22NLD0147F", annot[[k]]$Sample_ID), "Garderen",
ifelse(grepl("PDOM2022NLD0077M", annot[[k]]$Sample_ID), "Meerkerk",
ifelse(grepl("PDOM2022NLD0", annot[[k]]$Sample_ID), "Utrecht", "Error"))))))))))
corres_df <- as.data.frame(read.table(corres_files[k]))
rownames(corres_df) <- annot[[k]]$Sample_ID
colnames(corres_df) <- annot[[k]]$Sample_ID
corres_df$CHRType <- str_extract(corres_files[k], "(Allosome|Autosomes)")
corres_df$K <- str_extract(corres_files[k], "(K2|K3|K4|K5|K6|K7)")
corres[[k]] <- corres_df}
# Perform individual computation ~
# Perform individual computation ~
compute_on_matrices <- function(corres_ind_list, pop_list, ord_list) {
result <- lapply(1:length(corres_ind_list), function(i) {
corres_ind <- corres_ind_list[[i]]
pop <- pop_list[[i]]
ord <- ord_list[[i]]
corres_sub <- corres_ind
# Create annotation data frame
annotation_df <- data.frame(Sample_ID = rownames(corres_sub),
CHRType = NA,
K = NA)
# Match population and add annotation columns
for (j in 1:length(pop)) {
match_indices <- pop == names(pop[j])
annotation_df$CHRType[match_indices] <- ord$CHRType[match_indices]
annotation_df$K[match_indices] <- ord$K[match_indices]
}
# Combine annotation and individual matrix
indiv_matrix <- cbind(annotation_df, corres_sub)
# Remove redundant CHRType and K columns
indiv_matrix <- indiv_matrix[, c("Sample_ID", "CHRType", "K", grep("CHRType\\.|K\\.", colnames(corres_sub)))]
return(indiv_matrix)
})
return(result)
}
compute_mean_correlation <- function(corres_ind, pop, exclude_cols) {
N <- length(pop)
mean_cors <- matrix(NA, ncol = length(unique(pop)), nrow = length(unique(pop)))
colnames(mean_cors) <- unique(pop)
rownames(mean_cors) <- unique(pop)
for (i1 in 1:(length(unique(pop)))) {
for (i2 in 1:(length(unique(pop)))) {
p1 <- unique(pop)[i1]
p2 <- unique(pop)[i2]
# Filter out annotation columns if corres_sub has columns
corres_sub <- corres_ind[which(pop == p1), which(pop == p2)]
# Handle NAs in corres_sub
corres_sub[is.na(corres_sub)] <- 0
# Check if corres_sub is not empty
if (!is.null(corres_sub) && nrow(corres_sub) > 0 && ncol(corres_sub) > 0) {
# Check if there's only one individual in one or both populations
if (nrow(corres_sub) <= 1 || ncol(corres_sub) <= 1) {
mean_cors[i1, i2] <- 0
} else {
mean_cors[i1, i2] <- mean(corres_sub, na.rm = TRUE)
}
} else {
mean_cors[i1, i2] <- NA
}
}
}
return(mean_cors)
}
# Applies functions ~
main_list <- compute_on_matrices(corres_ind_list = corres,
pop_list = lapply(annot, function(ann) ann$Population),
ord_list = lapply(corres, orderInds))
### The BEGINNING ~~~~~
##
# ~ Plots NLSparrow--evalAdmix | First written by Jose Samaniego with later modifications by George Pacheco.
# Cleans the environment ~
rm(list=ls())
# Loads required packages ~
pacman::p_load(tidyverse, reshape2, pheatmap, scales, optparse, plyr, RColorBrewer, extrafont)
source("visFuns.R")
# Sets working directory ~
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Imports data while incorporating annotation ~
corres <- list()
annot <- list()
corres_files <- dir(pattern = ".corres")
annot_files <- dir(pattern = ".labels")
for (k in seq_along(annot_files)) {
annot[[k]] <- read.table(annot_files[k], sep = "\t", header = FALSE, stringsAsFactors = FALSE)
colnames(annot[[k]]) <- c("Sample_ID")
annot[[k]]$Population <- ifelse(grepl("FR0", annot[[k]]$Sample_ID), "Sales",
ifelse(grepl("KAZ", annot[[k]]$Sample_ID), "Chokpak",
ifelse(grepl("Lesina", annot[[k]]$Sample_ID), "Lesina",
ifelse(grepl("Crotone", annot[[k]]$Sample_ID), "Crotone",
ifelse(grepl("Guglionesi", annot[[k]]$Sample_ID), "Guglionesi",
ifelse(grepl("PI22NLD0001M", annot[[k]]$Sample_ID), "Y150239",
ifelse(grepl("PD22NLD0146F", annot[[k]]$Sample_ID), "Garderen",
ifelse(grepl("PD22NLD0147F", annot[[k]]$Sample_ID), "Garderen",
ifelse(grepl("PDOM2022NLD0077M", annot[[k]]$Sample_ID), "Meerkerk",
ifelse(grepl("PDOM2022NLD0", annot[[k]]$Sample_ID), "Utrecht", "Error"))))))))))
corres_df <- as.data.frame(read.table(corres_files[k]))
rownames(corres_df) <- annot[[k]]$Sample_ID
colnames(corres_df) <- annot[[k]]$Sample_ID
corres_df$CHRType <- str_extract(corres_files[k], "(Allosome|Autosomes)")
corres_df$K <- str_extract(corres_files[k], "(K2|K3|K4|K5|K6|K7)")
corres[[k]] <- corres_df}
# Perform individual computation ~
compute_on_matrices <- function(corres_ind_list, pop_list, ord_list) {
result <- lapply(1:length(corres_ind_list), function(i) {
corres_ind <- corres_ind_list[[i]]
pop <- pop_list[[i]]
ord <- ord_list[[i]]
corres_sub <- corres_ind
# Create annotation data frame
annotation_df <- data.frame(Sample_ID = rownames(corres_sub),
CHRType = NA,
K = NA)
# Match population and add annotation columns
for (j in 1:length(pop)) {
match_indices <- pop == names(pop[j])
if (is.data.frame(ord)) {
annotation_df$CHRType[match_indices] <- ord$CHRType[match_indices]
annotation_df$K[match_indices] <- ord$K[match_indices]
} else {
# If ord is not a data frame, it might be a named vector, so let's try this:
annotation_df$CHRType[match_indices] <- ord[match_indices]
annotation_df$K[match_indices] <- NA  # Or any other appropriate value
}
}
# Combine annotation and individual matrix
indiv_matrix <- cbind(annotation_df, corres_sub)
# Remove redundant CHRType and K columns
indiv_matrix <- indiv_matrix[, c("Sample_ID", "CHRType", "K", grep("CHRType\\.|K\\.", colnames(corres_sub)))]
return(indiv_matrix)
})
return(result)
}
compute_mean_correlation <- function(corres_ind, pop, exclude_cols) {
N <- length(pop)
mean_cors <- matrix(NA, ncol = length(unique(pop)), nrow = length(unique(pop)))
colnames(mean_cors) <- unique(pop)
rownames(mean_cors) <- unique(pop)
for (i1 in 1:(length(unique(pop)))) {
for (i2 in 1:(length(unique(pop)))) {
p1 <- unique(pop)[i1]
p2 <- unique(pop)[i2]
# Filter out annotation columns if corres_sub has columns
corres_sub <- corres_ind[which(pop == p1), which(pop == p2)]
# Handle NAs in corres_sub
corres_sub[is.na(corres_sub)] <- 0
# Check if corres_sub is not empty
if (!is.null(corres_sub) && nrow(corres_sub) > 0 && ncol(corres_sub) > 0) {
# Check if there's only one individual in one or both populations
if (nrow(corres_sub) <= 1 || ncol(corres_sub) <= 1) {
mean_cors[i1, i2] <- 0
} else {
mean_cors[i1, i2] <- mean(corres_sub, na.rm = TRUE)
}
} else {
mean_cors[i1, i2] <- NA
}
}
}
return(mean_cors)
}
# Applies functions ~
main_list <- compute_on_matrices(corres_ind_list = corres,
pop_list = lapply(annot, function(ann) ann$Population),
ord_list = lapply(corres, orderInds))
View(main_list)
### The BEGINNING ~~~~~
##
# ~ Plots NLSparrow--evalAdmix | First written by Jose Samaniego with later modifications by George Pacheco.
# Cleans the environment ~
rm(list=ls())
# Loads required packages ~
pacman::p_load(tidyverse, reshape2, pheatmap, scales, optparse, plyr, RColorBrewer, extrafont)
source("visFuns.R")
# Sets working directory ~
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Imports data while incorporating annotation ~
corres <- list()
annot <- list()
corres_files <- dir(pattern = ".corres")
annot_files <- dir(pattern = ".labels")
for (k in seq_along(annot_files)) {
annot[[k]] <- read.table(annot_files[k], sep = "\t", header = FALSE, stringsAsFactors = FALSE)
colnames(annot[[k]]) <- c("Sample_ID")
annot[[k]]$Population <- ifelse(grepl("FR0", annot[[k]]$Sample_ID), "Sales",
ifelse(grepl("KAZ", annot[[k]]$Sample_ID), "Chokpak",
ifelse(grepl("Lesina", annot[[k]]$Sample_ID), "Lesina",
ifelse(grepl("Crotone", annot[[k]]$Sample_ID), "Crotone",
ifelse(grepl("Guglionesi", annot[[k]]$Sample_ID), "Guglionesi",
ifelse(grepl("PI22NLD0001M", annot[[k]]$Sample_ID), "Y150239",
ifelse(grepl("PD22NLD0146F", annot[[k]]$Sample_ID), "Garderen",
ifelse(grepl("PD22NLD0147F", annot[[k]]$Sample_ID), "Garderen",
ifelse(grepl("PDOM2022NLD0077M", annot[[k]]$Sample_ID), "Meerkerk",
ifelse(grepl("PDOM2022NLD0", annot[[k]]$Sample_ID), "Utrecht", "Error"))))))))))
corres_df <- as.data.frame(read.table(corres_files[k]))
rownames(corres_df) <- annot[[k]]$Sample_ID
colnames(corres_df) <- annot[[k]]$Sample_ID
corres_df$CHRType <- str_extract(corres_files[k], "(Allosome|Autosomes)")
corres_df$K <- str_extract(corres_files[k], "(K2|K3|K4|K5|K6|K7)")
corres[[k]] <- corres_df}
# Perform individual computation ~
compute_on_matrices <- function(corres_ind_list, pop_list, ord_list) {
result <- lapply(1:length(corres_ind_list), function(i) {
corres_ind <- corres_ind_list[[i]]
pop <- pop_list[[i]]
ord <- ord_list[[i]]
corres_sub <- corres_ind
# Create annotation data frame
annotation_df <- data.frame(Sample_ID = rownames(corres_sub),
CHRType = NA,
K = NA)
# Match population and add annotation columns
for (j in 1:length(pop)) {
match_indices <- pop == names(pop[j])
if (is.data.frame(ord)) {
annotation_df$CHRType[match_indices] <- ord$CHRType[match_indices]
annotation_df$K[match_indices] <- ord$K[match_indices]
} else {
# If ord is not a data frame, it might be a named vector, so let's try this:
annotation_df$CHRType[match_indices] <- ord[match_indices]
annotation_df$K[match_indices] <- NA  # Or any other appropriate value
}
}
# Combine annotation and individual matrix
indiv_matrix <- cbind(annotation_df, corres_sub)
# Remove redundant CHRType and K columns
indiv_matrix <- indiv_matrix[, c("Sample_ID", "CHRType", "K", grep("CHRType\\.|K\\.", colnames(corres_sub)), invert = TRUE)]
return(indiv_matrix)
})
return(result)
}
compute_mean_correlation <- function(corres_ind, pop, exclude_cols) {
N <- length(pop)
mean_cors <- matrix(NA, ncol = length(unique(pop)), nrow = length(unique(pop)))
colnames(mean_cors) <- unique(pop)
rownames(mean_cors) <- unique(pop)
for (i1 in 1:(length(unique(pop)))) {
for (i2 in 1:(length(unique(pop)))) {
p1 <- unique(pop)[i1]
p2 <- unique(pop)[i2]
# Filter out annotation columns if corres_sub has columns
corres_sub <- corres_ind[which(pop == p1), which(pop == p2)]
# Handle NAs in corres_sub
corres_sub[is.na(corres_sub)] <- 0
# Check if corres_sub is not empty
if (!is.null(corres_sub) && nrow(corres_sub) > 0 && ncol(corres_sub) > 0) {
# Check if there's only one individual in one or both populations
if (nrow(corres_sub) <= 1 || ncol(corres_sub) <= 1) {
mean_cors[i1, i2] <- 0
} else {
mean_cors[i1, i2] <- mean(corres_sub, na.rm = TRUE)
}
} else {
mean_cors[i1, i2] <- NA
}
}
}
return(mean_cors)
}
# Applies functions ~
main_list <- compute_on_matrices(corres_ind_list = corres,
pop_list = lapply(annot, function(ann) ann$Population),
ord_list = lapply(corres, orderInds))
### The BEGINNING ~~~~~
##
# ~ Plots NLSparrow--evalAdmix | First written by Jose Samaniego with later modifications by George Pacheco.
# Cleans the environment ~
rm(list=ls())
# Loads required packages ~
pacman::p_load(tidyverse, reshape2, pheatmap, scales, optparse, plyr, RColorBrewer, extrafont)
source("visFuns.R")
# Sets working directory ~
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Imports data while incorporating annotation ~
corres <- list()
annot <- list()
corres_files <- dir(pattern = ".corres")
annot_files <- dir(pattern = ".labels")
for (k in seq_along(annot_files)) {
annot[[k]] <- read.table(annot_files[k], sep = "\t", header = FALSE, stringsAsFactors = FALSE)
colnames(annot[[k]]) <- c("Sample_ID")
annot[[k]]$Population <- ifelse(grepl("FR0", annot[[k]]$Sample_ID), "Sales",
ifelse(grepl("KAZ", annot[[k]]$Sample_ID), "Chokpak",
ifelse(grepl("Lesina", annot[[k]]$Sample_ID), "Lesina",
ifelse(grepl("Crotone", annot[[k]]$Sample_ID), "Crotone",
ifelse(grepl("Guglionesi", annot[[k]]$Sample_ID), "Guglionesi",
ifelse(grepl("PI22NLD0001M", annot[[k]]$Sample_ID), "Y150239",
ifelse(grepl("PD22NLD0146F", annot[[k]]$Sample_ID), "Garderen",
ifelse(grepl("PD22NLD0147F", annot[[k]]$Sample_ID), "Garderen",
ifelse(grepl("PDOM2022NLD0077M", annot[[k]]$Sample_ID), "Meerkerk",
ifelse(grepl("PDOM2022NLD0", annot[[k]]$Sample_ID), "Utrecht", "Error"))))))))))
corres_df <- as.data.frame(read.table(corres_files[k]))
rownames(corres_df) <- annot[[k]]$Sample_ID
colnames(corres_df) <- annot[[k]]$Sample_ID
corres_df$CHRType <- str_extract(corres_files[k], "(Allosome|Autosomes)")
corres_df$K <- str_extract(corres_files[k], "(K2|K3|K4|K5|K6|K7)")
corres[[k]] <- corres_df
}
# Perform individual computation ~
compute_on_matrices <- function(corres_ind_list, pop_list, ord_list) {
result <- lapply(1:length(corres_ind_list), function(i) {
corres_ind <- corres_ind_list[[i]]
pop <- pop_list[[i]]
ord <- ord_list[[i]]
corres_sub <- corres_ind
# Create annotation data frame
annotation_df <- data.frame(Sample_ID = rownames(corres_sub),
CHRType = rep(NA, nrow(corres_sub)),
K = rep(NA, nrow(corres_sub)))
# Match population and add annotation columns
for (j in 1:length(pop)) {
annotation_df[pop == names(pop[j]), c("CHRType", "K")] <- unique(ord[pop == names(pop[j])])
}
# Combine annotation and individual matrix
indiv_matrix <- cbind(annotation_df, corres_sub)
return(indiv_matrix)
})
return(result)}
compute_mean_correlation <- function(corres_ind, pop, exclude_cols) {
N <- length(pop)
mean_cors <- matrix(NA, ncol = length(unique(pop)), nrow = length(unique(pop)))
colnames(mean_cors) <- unique(pop)
rownames(mean_cors) <- unique(pop)
for (i1 in 1:(length(unique(pop)))) {
for (i2 in 1:(length(unique(pop)))) {
p1 <- unique(pop)[i1]
p2 <- unique(pop)[i2]
# Filter out annotation columns if corres_sub has columns
corres_sub <- corres_ind[which(pop == p1), which(pop == p2)]
# Handle NAs in corres_sub
corres_sub[is.na(corres_sub)] <- 0
# Check if corres_sub is not empty
if (!is.null(corres_sub) && nrow(corres_sub) > 0 && ncol(corres_sub) > 0) {
# Check if there's only one individual in one or both populations
if (nrow(corres_sub) <= 1 || ncol(corres_sub) <= 1) {
mean_cors[i1, i2] <- 0
} else {
mean_cors[i1, i2] <- mean(corres_sub, na.rm = TRUE)
}
} else {
mean_cors[i1, i2] <- NA
}
}
}
return(mean_cors)
}
# Applies functions ~
main_list <- compute_on_matrices(corres_ind_list = corres,
pop_list = lapply(annot, function(ann) ann$Population),
ord_list = lapply(corres, orderInds))
View(main_list)
