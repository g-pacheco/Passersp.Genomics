ungroup()
# Reorders CHRType ~
fulldf$CHRType <- factor(fulldf$CHRType, ordered = TRUE,
levels = c("Autosomes",
"Allosome"))
# Reorders K ~
fulldf$K <- factor(fulldf$K, ordered = TRUE,
levels = c("K = 7",
"K = 6",
"K = 5",
"K = 4",
"K = 3",
"K = 2"))
# Defines color palette and breaks ~
color_palette <- c("#023858", "#ffffff", "#a50f15")
nHalf <- 10
Min <- -.3
Max <- .3
Thresh <- 0
rc1 <- colorRampPalette(colors = color_palette[1:2], space = "Lab")(nHalf)
rc2 <- colorRampPalette(colors = color_palette[2:3], space = "Lab")(nHalf)
rampcols <- c(rc1, rc2)
rampcols[c(nHalf, nHalf+1)] <- rgb(t(col2rgb(color_palette[2])), maxColorValue = 256)
rb1 <- seq(Min, Thresh, length.out = nHalf + 1)
rb2 <- seq(Thresh, Max, length.out = nHalf + 1)[-1]
rampbreaks <- c(rb1, rb2)
# Sets factor levels for Sample_ID_1 and Sample_ID_2 based on orderInds ~
#ordered_labels <- unique(fulldf$Sample_ID_1)
#fulldf$Sample_ID_1 <- factor(fulldf$Sample_ID_1, levels = ordered_labels)
#fulldf$Sample_ID_2 <- factor(fulldf$Sample_ID_2, levels = ordered_labels)
# Iterate over the correlation matrices
for (k in seq_along(corres)) {
ordered_labels <- rownames(corres[[k]])
ordered_K <- corres[[k]]$K
ordered_labels_list[[k]] <- ordered_labels
fulldf$Sample_ID_1 = factor(Sample_ID_1, levels = ordered_labels)
fulldf$Sample_ID_2 = factor(Sample_ID_2, levels = ordered_labels)}
### The BEGINNING ~~~~~
##
# ~ Plots Y150239Genomics--evalAdmix | Written by George Pacheco with help from Jose Samaniego.
# Cleans the environment ~
rm(list=ls())
# Sets working directory ~
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Loads required packages ~
pacman::p_load(tidyverse, ggnewscale)
source("visFuns.R")
# Import and process data
corres <- list()
annot <- list()
ord_list <- list()
ordered_labels_list <- list()
corres_files <- dir(pattern = ".corres")
annot_files <- dir(pattern = ".labels")
qopt_files <- dir(pattern = ".qopt")
for (k in seq_along(annot_files)) {
annot[[k]] <- read.table(annot_files[k], sep = "\t", header = FALSE, stringsAsFactors = FALSE)
colnames(annot[[k]]) <- c("Annot")
annot[[k]]$Population <- ifelse(grepl("FR0", annot[[k]]$Annot), "Sales",
ifelse(grepl("KAZ", annot[[k]]$Annot), "Chokpak",
ifelse(grepl("Lesina", annot[[k]]$Annot), "Lesina",
ifelse(grepl("Crotone", annot[[k]]$Annot), "Crotone",
ifelse(grepl("Guglionesi", annot[[k]]$Annot), "Guglionesi",
ifelse(grepl("PI22NLD0001M", annot[[k]]$Annot), "Y150239",
ifelse(grepl("PDOM2022NLD0077M", annot[[k]]$Annot), "Meerkerk",
ifelse(grepl("PDOM2022NLD0", annot[[k]]$Annot), "Utrecht", "Error"))))))))
annot[[k]]$Ind <- with(annot[[k]], ave(Population, Population, FUN = function(x) sprintf("%s_%02d", x, seq_along(x))))
qopt_df <- NULL
if (length(qopt_files) >= k && file.exists(qopt_files[k])) {
qopt_df <- as.matrix(read.table(qopt_files[k], header = FALSE))}
corres_df <- as.data.frame(read.table(corres_files[k]))
labels <- annot[[k]]$Annot
pop <- annot[[k]]$Population
ord <- orderInds(q = qopt_df, pop = pop)
ord_list[[k]] <- ord
corres_df <- corres_df[ord, ord]
ordered_labels <- labels[ord]
rownames(corres_df) <- ordered_labels
colnames(corres_df) <- ordered_labels
corres_df$Sample_ID_1 <- rownames(corres_df)
corres_df$Population_1 <- annot[[k]]$Population
corres_df$CHRType <- str_extract(corres_files[k], "(Allosome|Autosomes)")
corres_df$K <- str_extract(corres_files[k], "(K2|K3|K4|K5|K6|K7)")
corres_df$K <- ifelse(grepl("K2", corres_df$K), "K = 2",
ifelse(grepl("K3", corres_df$K), "K = 3",
ifelse(grepl("K4", corres_df$K), "K = 4",
ifelse(grepl("K5", corres_df$K), "K = 5",
ifelse(grepl("K6", corres_df$K), "K = 6",
ifelse(grepl("K7", corres_df$K), "K = 7", "Error"))))))
corres[[k]] <- corres_df}
# Adjusted compute_mean_correlations function ~
compute_mean_correlations <- function(cor_mat_list, ord_list, pop) {
pop <- pop[ord]
unique_pops <- unique(pop)
num_pops <- length(unique_pops)
process_single_matrix <- function(cor_mat, ord, pop) {
pop <- pop[ord]
annotations <- cor_mat[, c("Sample_ID_1", "Population_1", "CHRType", "K")]
cor_mat <- cor_mat[, !(colnames(cor_mat) %in% c("Sample_ID_1", "Population_1", "CHRType", "K"))]
mean_cor_df <- data.frame(matrix(ncol = num_pops, nrow = num_pops))
rownames(mean_cor_df) <- unique_pops
colnames(mean_cor_df) <- unique_pops
for (i1 in 1:num_pops) {
for (i2 in 1:num_pops) {
p1 <- unique_pops[i1]
p2 <- unique_pops[i2]
indices_p1 <- which(pop == p1)
indices_p2 <- which(pop == p2)
cor_values <- cor_mat[indices_p1, indices_p2]
mean_cor_df[p1, p2] <- mean(cor_values[!is.na(cor_values)])}}
mean_cor_df[is.na(mean_cor_df)] <- 0
for (i1 in 1:(nrow(cor_mat) - 1)) {
for (i2 in (i1 + 1):nrow(cor_mat)) {
cor_mat[i2, i1] <- mean_cor_df[pop[i1], pop[i2]]
cor_mat[i1, i2] <- cor_mat[i1, i2]}
}
cor_mat <- cbind(annotations, cor_mat)
return(cor_mat)
}
# Create a list to store the data frames for each K
final_list <- list()
for (i in seq_along(cor_mat_list)) {
cor_mat_list[[i]] <- process_single_matrix(cor_mat_list[[i]], ord_list[[i]], pop)
# Store the result as a data frame for the current K
current_K <- unique(cor_mat_list[[i]]$K)  # Extract current K
final_list[[as.character(current_K)]] <- cor_mat_list[[i]]
}
return(final_list)
}
# Apply the updated function
final_list <- compute_mean_correlations(corres, ord_list, pop)
# Convert all matrices to numeric type
final_list <- lapply(final_list, as.matrix)
final_list <- lapply(final_list, as.data.frame)
# Combine all matrices for different K values into a single dataset
final_combined <- bind_rows(final_list, .id = "K_value")
# Select relevant columns and convert data from wide to long format
final_long_format <- final_combined %>%
pivot_longer(cols = -c(K_value, Sample_ID_1, Population_1, CHRType, K),
names_to = "Var2",
values_to = "value")
# Renames some columns and select the relevant ones ~
fulldf_final <- final_long_format %>%
rename_with(~"Sample_ID_2", Var2) %>%
rename_with(~"Value", value) %>%
select(Sample_ID_1, Sample_ID_2, Population_1, CHRType, K, Value)
# Gets Population_2 ~
fulldf_final <- fulldf_final %>%
mutate(Population_2 = ifelse(grepl("FR0", Sample_ID_2), "Sales",
ifelse(grepl("KAZ", Sample_ID_2), "Chokpak",
ifelse(grepl("Lesina", Sample_ID_2), "Lesina",
ifelse(grepl("Crotone", Sample_ID_2), "Crotone",
ifelse(grepl("Guglionesi", Sample_ID_2), "Guglionesi",
ifelse(grepl("PI22NLD0001M", Sample_ID_2), "Y150239",
ifelse(grepl("PDOM2022NLD0077M", Sample_ID_2), "Meerkerk",
ifelse(grepl("PDOM2022NLD0", Sample_ID_2), "Utrecht", "Error"))))))))) %>%
select(1:3, Population_2, everything())
# Reorders columns ~
fulldf <- fulldf_final %>%
select(Sample_ID_1, Sample_ID_2, Population_1, Population_2, CHRType, K, Value)
# Corrects Population names ~
levels(fulldf$Sample_ID_1 <- sub("Y150239_01", "Y150239", fulldf$Sample_ID_1))
levels(fulldf$Sample_ID_2 <- sub("Y150239_01", "Y150239", fulldf$Sample_ID_2))
# Function to assign Value based on the comparison
assign_value <- function(df) {df <- df %>%
mutate(Pair = paste0(pmin(Sample_ID_1, Sample_ID_2), "_", pmax(Sample_ID_1, Sample_ID_2)),
Triangle = ifelse(Sample_ID_1 == Sample_ID_2, "Diagonal",
ifelse(!duplicated(Pair), "Individual",
ifelse(duplicated(Pair), "Population", "Error")))) %>%
select(-Pair)
return(df)}
# Apply the function per K
fulldf <- fulldf %>%
group_by(K) %>%
do(assign_value(.)) %>%
ungroup()
# Reorders CHRType ~
fulldf$CHRType <- factor(fulldf$CHRType, ordered = TRUE,
levels = c("Autosomes",
"Allosome"))
# Reorders K ~
fulldf$K <- factor(fulldf$K, ordered = TRUE,
levels = c("K = 7",
"K = 6",
"K = 5",
"K = 4",
"K = 3",
"K = 2"))
# Defines color palette and breaks ~
color_palette <- c("#023858", "#ffffff", "#a50f15")
nHalf <- 10
Min <- -.3
Max <- .3
Thresh <- 0
rc1 <- colorRampPalette(colors = color_palette[1:2], space = "Lab")(nHalf)
rc2 <- colorRampPalette(colors = color_palette[2:3], space = "Lab")(nHalf)
rampcols <- c(rc1, rc2)
rampcols[c(nHalf, nHalf+1)] <- rgb(t(col2rgb(color_palette[2])), maxColorValue = 256)
rb1 <- seq(Min, Thresh, length.out = nHalf + 1)
rb2 <- seq(Thresh, Max, length.out = nHalf + 1)[-1]
rampbreaks <- c(rb1, rb2)
# Sets factor levels for Sample_ID_1 and Sample_ID_2 based on orderInds ~
#ordered_labels <- unique(fulldf$Sample_ID_1)
#fulldf$Sample_ID_1 <- factor(fulldf$Sample_ID_1, levels = ordered_labels)
#fulldf$Sample_ID_2 <- factor(fulldf$Sample_ID_2, levels = ordered_labels)
# Iterate over the correlation matrices
for (k in seq_along(corres)) {
ordered_labels <- rownames(corres[[k]])
ordered_K <- corres[[k]]$K
ordered_labels_list[[k]] <- ordered_labels
fulldf$Sample_ID_1 <- factor(fulldf$Sample_ID_1, levels = ordered_labels)
fulldf$Sample_ID_2 <- factor(fulldf$Sample_ID_2, levels = ordered_labels)}
View(fulldf)
# Safely convert to numeric factor
fulldf <- fulldf %>%
mutate(Sample_ID_Factor = as.numeric(Sample_ID_1))
# Calculate population positions
population_positions <- fulldf %>%
filter(!is.na(Sample_ID_Factor)) %>%
group_by(Population_1) %>%
summarise(center = (min(Sample_ID_Factor) + max(Sample_ID_Factor)) / 2)
# Creates heatmap ~
evalAdmix_Plot <-
ggplot(fulldf, aes(x = Sample_ID_1, y = Sample_ID_2, fill = Value)) +
geom_tile(linewidth = .15, colour = "#000000") +
#scale_fill_gradientn(colors = rampcols, na.value = "#d6d6d6", breaks = rampbreaks, limits = c(-.3, .3)) +
scale_x_discrete(labels = function(x) {
labels <- rep("", length(x))
for (i in seq_along(population_positions$center)) {
labels[population_positions$center[i]] <- population_positions$Population_1[i]}
return(labels)}, expand = c(0, 0)) +
scale_y_discrete(labels = fulldf$Sample_ID_2, expand = c(0, 0)) +
facet_grid(K ~ CHRType, scales = "free", space = "free") +
theme(panel.background = element_rect(fill = "#ffffff"),
panel.border = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.spacing = unit(1, "lines"),
legend.position = "right",
legend.key = element_blank(),
legend.background = element_blank(),
legend.margin = margin(t = 0, b = 0, r = 15, l = 15),
legend.box = "vertical",
legend.box.margin = margin(t = 20, b = 30, r = 0, l = 0),
axis.title = element_blank(),
axis.text.x = element_text(color = "#000000", family = "Optima", size = 12, face = "bold", angle = 45, vjust = 1, hjust = 1),
axis.text.y = element_text(color = "#000000", family = "Optima", size = 9, face = "bold"),
axis.ticks.x = element_blank(),
axis.ticks.y = element_line(color = "#000000", linewidth = .15),
strip.text = element_text(colour = "#000000", size = 22, face = "bold", family = "Optima"),
strip.background = element_rect(colour = "#000000", fill = "#d6d6d6", linewidth = .15),
axis.line = element_line(colour = "#000000", linewidth = .15)) +
guides(fill = guide_legend(title = "", title.theme = element_text(size = 16, face = "bold"),
label.theme = element_text(size = 15), ncol = 1, reverse = TRUE))
# Saves plot (Boxplot) ~
ggsave(evalAdmix_Plot, file = "Y150239Genomics--evalAdmix.pdf",
device = cairo_pdf, limitsize = FALSE, scale = 1, width = 14, height = 38, dpi = 600)
# Creates heatmap ~
evalAdmix_Plot <-
ggplot(fulldf, aes(x = Sample_ID_1, y = Sample_ID_2, fill = Value)) +
geom_tile(linewidth = .15, colour = "#000000") +
scale_fill_gradientn(colors = rampcols, na.value = "#d6d6d6", breaks = rampbreaks, limits = c(-.3, .3)) +
scale_x_discrete(labels = function(x) {
labels <- rep("", length(x))
for (i in seq_along(population_positions$center)) {
labels[population_positions$center[i]] <- population_positions$Population_1[i]}
return(labels)}, expand = c(0, 0)) +
scale_y_discrete(labels = fulldf$Sample_ID_2, expand = c(0, 0)) +
facet_grid(K ~ CHRType, scales = "free", space = "free") +
theme(panel.background = element_rect(fill = "#ffffff"),
panel.border = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.spacing = unit(1, "lines"),
legend.position = "right",
legend.key = element_blank(),
legend.background = element_blank(),
legend.margin = margin(t = 0, b = 0, r = 15, l = 15),
legend.box = "vertical",
legend.box.margin = margin(t = 20, b = 30, r = 0, l = 0),
axis.title = element_blank(),
axis.text.x = element_text(color = "#000000", family = "Optima", size = 12, face = "bold", angle = 45, vjust = 1, hjust = 1),
axis.text.y = element_text(color = "#000000", family = "Optima", size = 9, face = "bold"),
axis.ticks.x = element_blank(),
axis.ticks.y = element_line(color = "#000000", linewidth = .15),
strip.text = element_text(colour = "#000000", size = 22, face = "bold", family = "Optima"),
strip.background = element_rect(colour = "#000000", fill = "#d6d6d6", linewidth = .15),
axis.line = element_line(colour = "#000000", linewidth = .15)) +
guides(fill = guide_legend(title = "", title.theme = element_text(size = 16, face = "bold"),
label.theme = element_text(size = 15), ncol = 1, reverse = TRUE))
# Saves plot (Boxplot) ~
ggsave(evalAdmix_Plot, file = "Y150239Genomics--evalAdmix.pdf",
device = cairo_pdf, limitsize = FALSE, scale = 1, width = 14, height = 38, dpi = 600)
### The BEGINNING ~~~~~
##
# ~ Plots Y150239Genomics--evalAdmix | Written by George Pacheco with help from Jose Samaniego.
# Cleans the environment ~
rm(list=ls())
# Sets working directory ~
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Loads required packages ~
pacman::p_load(tidyverse, ggnewscale)
source("visFuns.R")
# Import and process data
corres <- list()
annot <- list()
ord_list <- list()
ordered_labels_list <- list()
corres_files <- dir(pattern = ".corres")
annot_files <- dir(pattern = ".labels")
qopt_files <- dir(pattern = ".qopt")
for (k in seq_along(annot_files)) {
annot[[k]] <- read.table(annot_files[k], sep = "\t", header = FALSE, stringsAsFactors = FALSE)
colnames(annot[[k]]) <- c("Annot")
annot[[k]]$Population <- ifelse(grepl("FR0", annot[[k]]$Annot), "Sales",
ifelse(grepl("KAZ", annot[[k]]$Annot), "Chokpak",
ifelse(grepl("Lesina", annot[[k]]$Annot), "Lesina",
ifelse(grepl("Crotone", annot[[k]]$Annot), "Crotone",
ifelse(grepl("Guglionesi", annot[[k]]$Annot), "Guglionesi",
ifelse(grepl("PI22NLD0001M", annot[[k]]$Annot), "Y150239",
ifelse(grepl("PDOM2022NLD0077M", annot[[k]]$Annot), "Meerkerk",
ifelse(grepl("PDOM2022NLD0", annot[[k]]$Annot), "Utrecht", "Error"))))))))
annot[[k]]$Ind <- with(annot[[k]], ave(Population, Population, FUN = function(x) sprintf("%s_%02d", x, seq_along(x))))
qopt_df <- NULL
if (length(qopt_files) >= k && file.exists(qopt_files[k])) {
qopt_df <- as.matrix(read.table(qopt_files[k], header = FALSE))}
corres_df <- as.data.frame(read.table(corres_files[k]))
labels <- annot[[k]]$Annot
pop <- annot[[k]]$Population
ord <- orderInds(q = qopt_df, pop = pop)
ord_list[[k]] <- ord
corres_df <- corres_df[ord, ord]
ordered_labels <- labels[ord]
rownames(corres_df) <- ordered_labels
colnames(corres_df) <- ordered_labels
corres_df$Sample_ID_1 <- rownames(corres_df)
corres_df$Population_1 <- annot[[k]]$Population
corres_df$CHRType <- str_extract(corres_files[k], "(Allosome|Autosomes)")
corres_df$K <- str_extract(corres_files[k], "(K2|K3|K4|K5|K6|K7)")
corres_df$K <- ifelse(grepl("K2", corres_df$K), "K = 2",
ifelse(grepl("K3", corres_df$K), "K = 3",
ifelse(grepl("K4", corres_df$K), "K = 4",
ifelse(grepl("K5", corres_df$K), "K = 5",
ifelse(grepl("K6", corres_df$K), "K = 6",
ifelse(grepl("K7", corres_df$K), "K = 7", "Error"))))))
corres[[k]] <- corres_df}
# Adjusted compute_mean_correlations function ~
compute_mean_correlations <- function(cor_mat_list, ord_list, pop) {
pop <- pop[ord]
unique_pops <- unique(pop)
num_pops <- length(unique_pops)
process_single_matrix <- function(cor_mat, ord, pop) {
pop <- pop[ord]
annotations <- cor_mat[, c("Sample_ID_1", "Population_1", "CHRType", "K")]
cor_mat <- cor_mat[, !(colnames(cor_mat) %in% c("Sample_ID_1", "Population_1", "CHRType", "K"))]
mean_cor_df <- data.frame(matrix(ncol = num_pops, nrow = num_pops))
rownames(mean_cor_df) <- unique_pops
colnames(mean_cor_df) <- unique_pops
for (i1 in 1:num_pops) {
for (i2 in 1:num_pops) {
p1 <- unique_pops[i1]
p2 <- unique_pops[i2]
indices_p1 <- which(pop == p1)
indices_p2 <- which(pop == p2)
cor_values <- cor_mat[indices_p1, indices_p2]
mean_cor_df[p1, p2] <- mean(cor_values[!is.na(cor_values)])}}
mean_cor_df[is.na(mean_cor_df)] <- 0
for (i1 in 1:(nrow(cor_mat) - 1)) {
for (i2 in (i1 + 1):nrow(cor_mat)) {
cor_mat[i2, i1] <- mean_cor_df[pop[i1], pop[i2]]
cor_mat[i1, i2] <- cor_mat[i1, i2]}
}
cor_mat <- cbind(annotations, cor_mat)
return(cor_mat)
}
# Create a list to store the data frames for each K
final_list <- list()
for (i in seq_along(cor_mat_list)) {
cor_mat_list[[i]] <- process_single_matrix(cor_mat_list[[i]], ord_list[[i]], pop)
# Store the result as a data frame for the current K
current_K <- unique(cor_mat_list[[i]]$K)  # Extract current K
final_list[[as.character(current_K)]] <- cor_mat_list[[i]]
}
return(final_list)
}
# Apply the updated function
final_list <- compute_mean_correlations(corres, ord_list, pop)
# Convert all matrices to numeric type
final_list <- lapply(final_list, as.matrix)
final_list <- lapply(final_list, as.data.frame)
# Combine all matrices for different K values into a single dataset
final_combined <- bind_rows(final_list, .id = "K_value")
# Select relevant columns and convert data from wide to long format
final_long_format <- final_combined %>%
pivot_longer(cols = -c(K_value, Sample_ID_1, Population_1, CHRType, K),
names_to = "Var2",
values_to = "value")
# Renames some columns and select the relevant ones ~
fulldf_final <- final_long_format %>%
rename_with(~"Sample_ID_2", Var2) %>%
rename_with(~"Value", value) %>%
select(Sample_ID_1, Sample_ID_2, Population_1, CHRType, K, Value)
# Gets Population_2 ~
fulldf_final <- fulldf_final %>%
mutate(Population_2 = ifelse(grepl("FR0", Sample_ID_2), "Sales",
ifelse(grepl("KAZ", Sample_ID_2), "Chokpak",
ifelse(grepl("Lesina", Sample_ID_2), "Lesina",
ifelse(grepl("Crotone", Sample_ID_2), "Crotone",
ifelse(grepl("Guglionesi", Sample_ID_2), "Guglionesi",
ifelse(grepl("PI22NLD0001M", Sample_ID_2), "Y150239",
ifelse(grepl("PDOM2022NLD0077M", Sample_ID_2), "Meerkerk",
ifelse(grepl("PDOM2022NLD0", Sample_ID_2), "Utrecht", "Error"))))))))) %>%
select(1:3, Population_2, everything())
# Reorders columns ~
fulldf <- fulldf_final %>%
select(Sample_ID_1, Sample_ID_2, Population_1, Population_2, CHRType, K, Value)
# Corrects Population names ~
levels(fulldf$Sample_ID_1 <- sub("Y150239_01", "Y150239", fulldf$Sample_ID_1))
levels(fulldf$Sample_ID_2 <- sub("Y150239_01", "Y150239", fulldf$Sample_ID_2))
# Function to assign Value based on the comparison
assign_value <- function(df) {df <- df %>%
mutate(Pair = paste0(pmin(Sample_ID_1, Sample_ID_2), "_", pmax(Sample_ID_1, Sample_ID_2)),
Triangle = ifelse(Sample_ID_1 == Sample_ID_2, "Diagonal",
ifelse(!duplicated(Pair), "Individual",
ifelse(duplicated(Pair), "Population", "Error")))) %>%
select(-Pair)
return(df)}
# Apply the function per K
fulldf <- fulldf %>%
group_by(K) %>%
do(assign_value(.)) %>%
ungroup()
# Reorders CHRType ~
fulldf$CHRType <- factor(fulldf$CHRType, ordered = TRUE,
levels = c("Autosomes",
"Allosome"))
# Reorders K ~
fulldf$K <- factor(fulldf$K, ordered = TRUE,
levels = c("K = 7",
"K = 6",
"K = 5",
"K = 4",
"K = 3",
"K = 2"))
# Defines color palette and breaks ~
color_palette <- c("#023858", "#ffffff", "#a50f15")
nHalf <- 10
Min <- -.3
Max <- .3
Thresh <- 0
rc1 <- colorRampPalette(colors = color_palette[1:2], space = "Lab")(nHalf)
rc2 <- colorRampPalette(colors = color_palette[2:3], space = "Lab")(nHalf)
rampcols <- c(rc1, rc2)
rampcols[c(nHalf, nHalf+1)] <- rgb(t(col2rgb(color_palette[2])), maxColorValue = 256)
rb1 <- seq(Min, Thresh, length.out = nHalf + 1)
rb2 <- seq(Thresh, Max, length.out = nHalf + 1)[-1]
rampbreaks <- c(rb1, rb2)
# Sets factor levels for Sample_ID_1 and Sample_ID_2 based on orderInds ~
#ordered_labels <- unique(fulldf$Sample_ID_1)
#fulldf$Sample_ID_1 <- factor(fulldf$Sample_ID_1, levels = ordered_labels)
#fulldf$Sample_ID_2 <- factor(fulldf$Sample_ID_2, levels = ordered_labels)
# Iterate over the correlation matrices
#for (k in seq_along(corres)) {
#  ordered_labels <- rownames(corres[[k]])
#  ordered_K <- corres[[k]]$K
#  ordered_labels_list[[k]] <- ordered_labels
#  fulldf$Sample_ID_1 <- factor(fulldf$Sample_ID_1, levels = ordered_labels)
#  fulldf$Sample_ID_2 <- factor(fulldf$Sample_ID_2, levels = ordered_labels)}
# Safely convert to numeric factor
fulldf <- fulldf %>%
mutate(Sample_ID_Factor = as.numeric(Sample_ID_1))
# Calculate population positions
population_positions <- fulldf %>%
filter(!is.na(Sample_ID_Factor)) %>%
group_by(Population_1) %>%
summarise(center = (min(Sample_ID_Factor) + max(Sample_ID_Factor)) / 2)
# Creates heatmap ~
evalAdmix_Plot <-
ggplot(fulldf, aes(x = Sample_ID_1, y = Sample_ID_2, fill = Value)) +
geom_tile(linewidth = .15, colour = "#000000") +
scale_fill_gradientn(colors = rampcols, na.value = "#d6d6d6", breaks = rampbreaks, limits = c(-.3, .3)) +
scale_x_discrete(labels = function(x) {
labels <- rep("", length(x))
for (i in seq_along(population_positions$center)) {
labels[population_positions$center[i]] <- population_positions$Population_1[i]}
return(labels)}, expand = c(0, 0)) +
scale_y_discrete(labels = fulldf$Sample_ID_2, expand = c(0, 0)) +
facet_grid(K ~ CHRType, scales = "free", space = "free") +
theme(panel.background = element_rect(fill = "#ffffff"),
panel.border = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.spacing = unit(1, "lines"),
legend.position = "right",
legend.key = element_blank(),
legend.background = element_blank(),
legend.margin = margin(t = 0, b = 0, r = 15, l = 15),
legend.box = "vertical",
legend.box.margin = margin(t = 20, b = 30, r = 0, l = 0),
axis.title = element_blank(),
axis.text.x = element_text(color = "#000000", family = "Optima", size = 12, face = "bold", angle = 45, vjust = 1, hjust = 1),
axis.text.y = element_text(color = "#000000", family = "Optima", size = 9, face = "bold"),
axis.ticks.x = element_blank(),
axis.ticks.y = element_line(color = "#000000", linewidth = .15),
strip.text = element_text(colour = "#000000", size = 22, face = "bold", family = "Optima"),
strip.background = element_rect(colour = "#000000", fill = "#d6d6d6", linewidth = .15),
axis.line = element_line(colour = "#000000", linewidth = .15)) +
guides(fill = guide_legend(title = "", title.theme = element_text(size = 16, face = "bold"),
label.theme = element_text(size = 15), ncol = 1, reverse = TRUE))
# Saves plot (Boxplot) ~
ggsave(evalAdmix_Plot, file = "Y150239Genomics--evalAdmix.pdf",
device = cairo_pdf, limitsize = FALSE, scale = 1, width = 14, height = 38, dpi = 600)
